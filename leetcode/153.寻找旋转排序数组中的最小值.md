# 153. 寻找旋转排序数组中的最小值

https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。


示例 1：
```
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```
示例 2：
```
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
```
示例 3：
```
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```


提示：

- n == nums.length
- 1 <= n <= 5000
- -5000 <= nums[i] <= 5000
- nums 中的所有整数 互不相同
- nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转

# 思路

旋转其实是将尾部的数字移到头部，可能会产生两个有序序列，并且前一个有序序列整体比后一个有序序列大。

找到最小值，也就是要将左右边界往两个序列分割点靠近

**确定比较对象**：常规思路会选择和左边界比较，但在当前场景中和左边界比较并不是一个好选择

![fig1](assets/1.png)

如果和左边界比较

- 小于等于左值，往左边区间靠
- 大于左值，往右边区间靠

左边界从左向右靠近最小值，可能会和最小值重合。中值大于左值的情况会有两种场景

1. 两值都在在前一有序序列中，要往右边区间靠
2. 两值都在后一有序序列中，要往左边区间靠

最小值及其左侧可能比右侧大也可能比右侧小，这样就无法用同一逻辑覆盖两种情况。

那么选择和右边界比较会怎么样呢？

- 小于等于右值，往左边区间靠
- 大于右值，往右边区间靠

因为整体趋势是减小的，最小值及其右侧总是比左侧小，不存在多种情况。

**确定细节**：从结果出发，希望最小值包含在区间中。最小值的范围在最左端到最右端，选择左闭右闭区间

- 起始条件：左闭右闭，`r = nums.length - 1`
- 上下界更新：最小值包含在区间中，`r = mid`
- 终止条件：`l === r` 时找到最小值，`while(l < r)`
- 返回值：`return nums[r]`



[https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/)